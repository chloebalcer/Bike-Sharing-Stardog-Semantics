{"ast":null,"code":"const {\n  Connection,\n  query\n} = require('stardog'); // Table column data, encoding the order, label, and \"selector\" for grabbing the\n// data for each column.\n\n\nconst columnData = [{\n  selector: \"number\",\n  label: \"Number\"\n}, {\n  selector: \"address\",\n  label: \"Address\"\n}, {\n  selector: \"bikes\",\n  label: \"Available bikes\"\n}, {\n  selector: \"stands\",\n  label: \"Available stands\"\n}, {\n  selector: \"lat\",\n  label: \"Latitude\"\n}, {\n  selector: \"lng\",\n  label: \"Longitude \"\n}]; // For convenience, we'll also produce the array of selectors just once, and\n// export it for re-use.\n\nconst columnSelectors = columnData.reduce((selectors, {\n  selector\n}) => [...selectors, selector], []); // In a typical application, the connection would be changeable. For our\n// present purposes, though, this is unchanging and hard-coded.\n\nconst conn = new Connection({\n  username: \"admin\",\n  password: \"admin\",\n  endpoint: \"http://localhost:5820\"\n}); // An \"enum\" for the status of our request to Stardog for data.\n\nconst TableDataAvailabilityStatus = {\n  NOT_REQUESTED: 'NOT_REQUESTED',\n  LOADING: \"LOADING\",\n  LOADED: \"LOADED\",\n  FAILED: \"FAILED\"\n};\nmodule.exports = {\n  dbName: 'lyon_bikes',\n  columnData,\n  columnSelectors,\n  conn,\n  TableDataAvailabilityStatus\n};\n\nfunction Localisation(lat, lng) {\n  return {\n    latitude: lat,\n    longitude: lng\n  };\n}\n\nquery.execute(conn, 'lyon_bikes', \"select ?lat ?lng where { ?l <http://schema.org/number> ?number . ?l <http://schema.org/lat> ?lat . ?l <http://schema.org/lng> ?lng .}\", 'application/sparql-results+json', {\n  limit: 10,\n  offset: 0\n}).then(({\n  body\n}) => {\n  const stores = [];\n  body.results.bindings.map(function (line) {\n    stores.push(Localisation(parseFloat(line.lat.value), parseFloat(line.lng.value)));\n  });\n  return stores;\n});","map":{"version":3,"sources":["/Users/chloebalcer/bikeStation/frontend/src/helpers/constants.js"],"names":["Connection","query","require","columnData","selector","label","columnSelectors","reduce","selectors","conn","username","password","endpoint","TableDataAvailabilityStatus","NOT_REQUESTED","LOADING","LOADED","FAILED","module","exports","dbName","Localisation","lat","lng","latitude","longitude","execute","limit","offset","then","body","stores","results","bindings","map","line","push","parseFloat","value"],"mappings":"AAAA,MAAM;AAAEA,EAAAA,UAAF;AAAcC,EAAAA;AAAd,IAAwBC,OAAO,CAAC,SAAD,CAArC,C,CAEA;AACA;;;AACA,MAAMC,UAAU,GAAG,CAEjB;AACEC,EAAAA,QAAQ,EAAE,QADZ;AAEEC,EAAAA,KAAK,EAAE;AAFT,CAFiB,EAMjB;AACED,EAAAA,QAAQ,EAAE,SADZ;AAEEC,EAAAA,KAAK,EAAE;AAFT,CANiB,EASf;AACAD,EAAAA,QAAQ,EAAE,OADV;AAEAC,EAAAA,KAAK,EAAE;AAFP,CATe,EAYf;AACAD,EAAAA,QAAQ,EAAE,QADV;AAEAC,EAAAA,KAAK,EAAE;AAFP,CAZe,EAgBjB;AACED,EAAAA,QAAQ,EAAE,KADZ;AAEEC,EAAAA,KAAK,EAAE;AAFT,CAhBiB,EAmBf;AACAD,EAAAA,QAAQ,EAAE,KADV;AAEAC,EAAAA,KAAK,EAAE;AAFP,CAnBe,CAAnB,C,CAyBA;AACA;;AACA,MAAMC,eAAe,GAAGH,UAAU,CAACI,MAAX,CACtB,CAACC,SAAD,EAAY;AAAEJ,EAAAA;AAAF,CAAZ,KAA6B,CAAC,GAAGI,SAAJ,EAAeJ,QAAf,CADP,EAEtB,EAFsB,CAAxB,C,CAKA;AACA;;AACA,MAAMK,IAAI,GAAG,IAAIT,UAAJ,CAAe;AAC1BU,EAAAA,QAAQ,EAAE,OADgB;AAE1BC,EAAAA,QAAQ,EAAE,OAFgB;AAG1BC,EAAAA,QAAQ,EAAE;AAHgB,CAAf,CAAb,C,CAMA;;AACA,MAAMC,2BAA2B,GAAG;AAClCC,EAAAA,aAAa,EAAE,eADmB;AAElCC,EAAAA,OAAO,EAAE,SAFyB;AAGlCC,EAAAA,MAAM,EAAE,QAH0B;AAIlCC,EAAAA,MAAM,EAAE;AAJ0B,CAApC;AAOAC,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,MAAM,EAAE,YADO;AAEfjB,EAAAA,UAFe;AAGfG,EAAAA,eAHe;AAIfG,EAAAA,IAJe;AAKfI,EAAAA;AALe,CAAjB;;AAQA,SAASQ,YAAT,CAAsBC,GAAtB,EAA2BC,GAA3B,EAAgC;AAC9B,SAAO;AACLC,IAAAA,QAAQ,EAAEF,GADL;AAELG,IAAAA,SAAS,EAAEF;AAFN,GAAP;AAID;;AAEDtB,KAAK,CAACyB,OAAN,CAAcjB,IAAd,EAAoB,YAApB,EAAkC,uIAAlC,EAA2K,iCAA3K,EAA8M;AAC5MkB,EAAAA,KAAK,EAAE,EADqM;AAE5MC,EAAAA,MAAM,EAAE;AAFoM,CAA9M,EAGGC,IAHH,CAGQ,CAAC;AAAEC,EAAAA;AAAF,CAAD,KAAc;AACpB,QAAMC,MAAM,GAAG,EAAf;AACAD,EAAAA,IAAI,CAACE,OAAL,CAAaC,QAAb,CAAsBC,GAAtB,CAA0B,UAASC,IAAT,EAAc;AAACJ,IAAAA,MAAM,CAACK,IAAP,CAAYf,YAAY,CAACgB,UAAU,CAACF,IAAI,CAACb,GAAL,CAASgB,KAAV,CAAX,EAA6BD,UAAU,CAACF,IAAI,CAACZ,GAAL,CAASe,KAAV,CAAvC,CAAxB;AAAkF,GAA3H;AACA,SAAOP,MAAP;AACD,CAPD","sourcesContent":["const { Connection, query } = require('stardog');\n \n// Table column data, encoding the order, label, and \"selector\" for grabbing the\n// data for each column.\nconst columnData = [\n  \n  {\n    selector: \"number\",\n    label: \"Number\"\n  },\n  {\n    selector: \"address\",\n    label: \"Address\"\n  },{\n    selector: \"bikes\",\n    label: \"Available bikes\"\n  },{\n    selector: \"stands\",\n    label: \"Available stands\"\n  },\n  {\n    selector: \"lat\",\n    label: \"Latitude\"\n  },{\n    selector: \"lng\",\n    label: \"Longitude \"\n  }\n];\n\n// For convenience, we'll also produce the array of selectors just once, and\n// export it for re-use.\nconst columnSelectors = columnData.reduce(\n  (selectors, { selector }) => [...selectors, selector],\n  []\n);\n\n// In a typical application, the connection would be changeable. For our\n// present purposes, though, this is unchanging and hard-coded.\nconst conn = new Connection({\n  username: \"admin\",\n  password: \"admin\",\n  endpoint: \"http://localhost:5820\"\n});\n\n// An \"enum\" for the status of our request to Stardog for data.\nconst TableDataAvailabilityStatus = {\n  NOT_REQUESTED: 'NOT_REQUESTED',\n  LOADING: \"LOADING\",\n  LOADED: \"LOADED\",\n  FAILED: \"FAILED\"\n};\n\nmodule.exports = {\n  dbName: 'lyon_bikes',\n  columnData,\n  columnSelectors,\n  conn,\n  TableDataAvailabilityStatus,\n};\n\nfunction Localisation(lat, lng) {\n  return {\n    latitude: lat,\n    longitude: lng\n  };\n}\n\nquery.execute(conn, 'lyon_bikes', \"select ?lat ?lng where { ?l <http://schema.org/number> ?number . ?l <http://schema.org/lat> ?lat . ?l <http://schema.org/lng> ?lng .}\", 'application/sparql-results+json', {\n  limit: 10,\n  offset: 0,\n}).then(({ body }) => {\n  const stores = []\n  body.results.bindings.map(function(line){stores.push(Localisation(parseFloat(line.lat.value), parseFloat(line.lng.value)))}); \n  return(stores);\n});"]},"metadata":{},"sourceType":"module"}