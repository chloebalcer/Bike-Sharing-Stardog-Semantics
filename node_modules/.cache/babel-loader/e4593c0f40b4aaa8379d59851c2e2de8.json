{"ast":null,"code":"const {\n  Connection\n} = require(\"stardog\"); // Table column data, encoding the order, label, and \"selector\" for grabbing the\n// data for each column.\n\n\nconst columnData = [{\n  selector: \"id\",\n  label: \"ID\"\n}, {\n  selector: \"name\",\n  label: \"Name\"\n}, {\n  selector: \"movie\",\n  label: \"Movies\"\n}, {\n  selector: \"homePlanet\",\n  label: \"Home Planet\"\n}, {\n  selector: \"kind\",\n  label: \"Kind\"\n}]; // For convenience, we'll also produce the array of selectors just once, and\n// export it for re-use.\n\nconst columnSelectors = columnData.reduce((selectors, {\n  selector\n}) => [...selectors, selector], []); // In a typical application, the connection would be changeable. For our\n// present purposes, though, this is unchanging and hard-coded.\n\nconst conn = new Connection({\n  username: \"admin\",\n  password: \"admin\",\n  endpoint: \"http://localhost:5820\"\n}); // An \"enum\" for the status of our request to Stardog for data.\n\nconst TableDataAvailabilityStatus = {\n  NOT_REQUESTED: 'NOT_REQUESTED',\n  LOADING: \"LOADING\",\n  LOADED: \"LOADED\",\n  FAILED: \"FAILED\"\n};\nmodule.exports = {\n  dbName: 'StarWarsDB',\n  columnData,\n  columnSelectors,\n  conn,\n  TableDataAvailabilityStatus\n}; // const { Connection, query } = require('stardog');\n// // Table column data, encoding the order, label, and \"selector\" for grabbing the\n// // data for each column.\n// const columnData = [\n//   {\n//     selector: \"recordid\",\n//     label: \"Id\"\n//   },\n//   {\n//     selector: \"adresse\",\n//     label: \"Adresse\"\n//   },\n//   {\n//     selector: \"commune\",\n//     label: \"Commune\"\n//   },\n//   {\n//     selector: \"nbvelosdispo\",\n//     label: \"Nombre Velos Dispo\"\n//   },{\n//     selector: \"nbplacesdispo\",\n//     label: \"Nombre Places Dispo\"\n//   },\n// ];\n// // For convenience, we'll also produce the array of selectors just once, and\n// // export it for re-use.\n// const columnSelectors = columnData.reduce(\n//   (selectors, { selector }) => [...selectors, selector],\n//   []\n// );\n// // In a typical application, the connection would be changeable. For our\n// // present purposes, though, this is unchanging and hard-coded.\n// const conn = new Connection({\n//   username: \"admin\",\n//   password: \"admin\",\n//   endpoint: \"http://localhost:5820\"\n// });\n// // An \"enum\" for the status of our request to Stardog for data.\n// const TableDataAvailabilityStatus = {\n//   NOT_REQUESTED: 'NOT_REQUESTED',\n//   LOADING: \"LOADING\",\n//   LOADED: \"LOADED\",\n//   FAILED: \"FAILED\"\n// };\n// module.exports = {\n//   dbName: 'vlille_ontology',\n//   columnData,\n//   columnSelectors,\n//   conn,\n//   TableDataAvailabilityStatus,\n// };\n// query.execute(conn, 'vlille', 'select distinct ?id where { ?id <http://www.schema.org#adresse> \"3 PLACE RICHEBE\" .  }', 'application/sparql-results+json', {\n//   limit: 10,\n//   offset: 0,\n// }).then(({ body }) => {\n//   console.log(body.results.bindings);\n// });","map":{"version":3,"sources":["/Users/chloebalcer/bikeStation/frontend/src/helpers/constants.js"],"names":["Connection","require","columnData","selector","label","columnSelectors","reduce","selectors","conn","username","password","endpoint","TableDataAvailabilityStatus","NOT_REQUESTED","LOADING","LOADED","FAILED","module","exports","dbName"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAiBC,OAAO,CAAC,SAAD,CAA9B,C,CAEA;AACA;;;AACA,MAAMC,UAAU,GAAG,CACjB;AACEC,EAAAA,QAAQ,EAAE,IADZ;AAEEC,EAAAA,KAAK,EAAE;AAFT,CADiB,EAKjB;AACED,EAAAA,QAAQ,EAAE,MADZ;AAEEC,EAAAA,KAAK,EAAE;AAFT,CALiB,EASjB;AACED,EAAAA,QAAQ,EAAE,OADZ;AAEEC,EAAAA,KAAK,EAAE;AAFT,CATiB,EAajB;AACED,EAAAA,QAAQ,EAAE,YADZ;AAEEC,EAAAA,KAAK,EAAE;AAFT,CAbiB,EAiBjB;AACED,EAAAA,QAAQ,EAAE,MADZ;AAEEC,EAAAA,KAAK,EAAE;AAFT,CAjBiB,CAAnB,C,CAuBA;AACA;;AACA,MAAMC,eAAe,GAAGH,UAAU,CAACI,MAAX,CACtB,CAACC,SAAD,EAAY;AAAEJ,EAAAA;AAAF,CAAZ,KAA6B,CAAC,GAAGI,SAAJ,EAAeJ,QAAf,CADP,EAEtB,EAFsB,CAAxB,C,CAKA;AACA;;AACA,MAAMK,IAAI,GAAG,IAAIR,UAAJ,CAAe;AAC1BS,EAAAA,QAAQ,EAAE,OADgB;AAE1BC,EAAAA,QAAQ,EAAE,OAFgB;AAG1BC,EAAAA,QAAQ,EAAE;AAHgB,CAAf,CAAb,C,CAMA;;AACA,MAAMC,2BAA2B,GAAG;AAClCC,EAAAA,aAAa,EAAE,eADmB;AAElCC,EAAAA,OAAO,EAAE,SAFyB;AAGlCC,EAAAA,MAAM,EAAE,QAH0B;AAIlCC,EAAAA,MAAM,EAAE;AAJ0B,CAApC;AAOAC,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,MAAM,EAAE,YADO;AAEfjB,EAAAA,UAFe;AAGfG,EAAAA,eAHe;AAIfG,EAAAA,IAJe;AAKfI,EAAAA;AALe,CAAjB,C,CAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["const { Connection } = require(\"stardog\");\n\n// Table column data, encoding the order, label, and \"selector\" for grabbing the\n// data for each column.\nconst columnData = [\n  {\n    selector: \"id\",\n    label: \"ID\"\n  },\n  {\n    selector: \"name\",\n    label: \"Name\"\n  },\n  {\n    selector: \"movie\",\n    label: \"Movies\"\n  },\n  {\n    selector: \"homePlanet\",\n    label: \"Home Planet\"\n  },\n  {\n    selector: \"kind\",\n    label: \"Kind\"\n  },\n];\n\n// For convenience, we'll also produce the array of selectors just once, and\n// export it for re-use.\nconst columnSelectors = columnData.reduce(\n  (selectors, { selector }) => [...selectors, selector],\n  []\n);\n\n// In a typical application, the connection would be changeable. For our\n// present purposes, though, this is unchanging and hard-coded.\nconst conn = new Connection({\n  username: \"admin\",\n  password: \"admin\",\n  endpoint: \"http://localhost:5820\"\n});\n\n// An \"enum\" for the status of our request to Stardog for data.\nconst TableDataAvailabilityStatus = {\n  NOT_REQUESTED: 'NOT_REQUESTED',\n  LOADING: \"LOADING\",\n  LOADED: \"LOADED\",\n  FAILED: \"FAILED\"\n};\n\nmodule.exports = {\n  dbName: 'StarWarsDB',\n  columnData,\n  columnSelectors,\n  conn,\n  TableDataAvailabilityStatus,\n};\n\n// const { Connection, query } = require('stardog');\n \n// // Table column data, encoding the order, label, and \"selector\" for grabbing the\n// // data for each column.\n// const columnData = [\n//   {\n//     selector: \"recordid\",\n//     label: \"Id\"\n//   },\n//   {\n//     selector: \"adresse\",\n//     label: \"Adresse\"\n//   },\n//   {\n//     selector: \"commune\",\n//     label: \"Commune\"\n//   },\n//   {\n//     selector: \"nbvelosdispo\",\n//     label: \"Nombre Velos Dispo\"\n//   },{\n//     selector: \"nbplacesdispo\",\n//     label: \"Nombre Places Dispo\"\n//   },\n// ];\n\n// // For convenience, we'll also produce the array of selectors just once, and\n// // export it for re-use.\n// const columnSelectors = columnData.reduce(\n//   (selectors, { selector }) => [...selectors, selector],\n//   []\n// );\n\n// // In a typical application, the connection would be changeable. For our\n// // present purposes, though, this is unchanging and hard-coded.\n// const conn = new Connection({\n//   username: \"admin\",\n//   password: \"admin\",\n//   endpoint: \"http://localhost:5820\"\n// });\n\n// // An \"enum\" for the status of our request to Stardog for data.\n// const TableDataAvailabilityStatus = {\n//   NOT_REQUESTED: 'NOT_REQUESTED',\n//   LOADING: \"LOADING\",\n//   LOADED: \"LOADED\",\n//   FAILED: \"FAILED\"\n// };\n\n// module.exports = {\n//   dbName: 'vlille_ontology',\n//   columnData,\n//   columnSelectors,\n//   conn,\n//   TableDataAvailabilityStatus,\n// };\n\n// query.execute(conn, 'vlille', 'select distinct ?id where { ?id <http://www.schema.org#adresse> \"3 PLACE RICHEBE\" .  }', 'application/sparql-results+json', {\n//   limit: 10,\n//   offset: 0,\n// }).then(({ body }) => {\n//   console.log(body.results.bindings);\n// });"]},"metadata":{},"sourceType":"module"}