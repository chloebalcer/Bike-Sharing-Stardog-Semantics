{"ast":null,"code":"var _jsxFileName = \"/Users/chloebalcer/bikeStation/frontend/src/components/bikes/searchBike.js\";\nimport React, { Component } from 'react';\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nimport Paper from \"@material-ui/core/Paper\";\nimport Table from \"@material-ui/core/Table\";\nimport TableBody from \"@material-ui/core/TableBody\";\nimport TableCell from \"@material-ui/core/TableCell\";\nimport TableHead from \"@material-ui/core/TableHead\";\nimport TableRow from \"@material-ui/core/TableRow\";\nimport Toolbar from \"@material-ui/core/Toolbar\";\nimport Typography from \"@material-ui/core/Typography\";\nimport CircularProgress from '@material-ui/core/CircularProgress';\nimport { query } from \"stardog\";\nimport { TableDataAvailabilityStatus, columnData, columnSelectors, conn, dbName } from \"../../helpers/constants\";\nconst readQuery = `select ?number ?address ?lat ?lng ?bikes ?stands ?commune\nwhere {\n    ?l <http://schema.org/number> ?number .\n    ?l <http://schema.org/address> ?address .\n    ?l <http://schema.org/available_bikes> ?bikes .\n    ?l <http://schema.org/available_bike_stands> ?stands .\n    ?l <http://schema.org/lat> ?lat .\n    ?l <http://schema.org/commune> {this.state.city} .\n    \n}\n`;\n\nclass SearchBike extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      dataState: TableDataAvailabilityStatus.NOT_REQUESTED,\n      data: [],\n      city: ''\n    };\n    this.updateInput = this.updateInput.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  updateInput(event) {\n    this.setState({\n      city: event.target.value\n    });\n  }\n\n  handleSubmit() {\n    console.log('Your input value is: ' + this.state.city); //Send state to the server code\n  }\n\n  getBindingValueForSelector(selector, binding) {\n    const bindingValue = binding[selector === \"movie\" ? \"movies\" : selector]; // NOTE: In a production app, we would probably want to do this formatting elsewhere.\n\n    return Array.isArray(bindingValue) ? bindingValue.join(\", \") : bindingValue;\n  }\n\n  renderRowForBinding(binding, index) {\n    return (\n      /*#__PURE__*/\n      // Use every \"selector\" to extract table cell data from each binding.\n      React.createElement(TableRow, {\n        key: binding.number,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 68,\n          columnNumber: 7\n        }\n      }, columnSelectors.map(selector => /*#__PURE__*/React.createElement(TableCell, {\n        key: selector,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 70,\n          columnNumber: 11\n        }\n      }, this.getBindingValueForSelector(selector, binding))))\n    );\n  }\n\n  componentDidMount() {\n    this.refreshData();\n  }\n\n  refreshData() {\n    this.setState({\n      dataState: TableDataAvailabilityStatus.LOADING\n    });\n    query.execute(conn, dbName, readQuery).then(res => {\n      if (!res.ok) {\n        this.setState({\n          dataState: TableDataAvailabilityStatus.FAILED\n        });\n        return;\n      }\n\n      const {\n        bindings\n      } = res.body.results;\n      const bindingsForTable = this.getBindingsFormattedForTable(bindings);\n      this.setState({\n        dataState: TableDataAvailabilityStatus.LOADED,\n        data: bindingsForTable\n      });\n    });\n  } // Our SPARQL query returns a new \"row\" (i.e., variable binding) for each\n  // character for each movie in which the character appears. We don't want to\n  // _display_ multiple rows for the same character, though. Instead, we want\n  // to show _one_ row for each character, and, if the character was in several\n  // movies, we want to show them as a group within that character's single row. This\n  // method goes through the bindings, groups them under each individual\n  // character's id, then merges them together, aggregating the movies as an\n  // array of strings. It also cleans up some of the data so that it's more\n  // readable in the UI.\n\n\n  getBindingsFormattedForTable(bindings) {\n    // Group the bindings by each character id, in case multiple rows were\n    // returned for a single character.\n    const bindingsById = bindings.reduce((groupedBindings, binding) => {\n      const {\n        value: number\n      } = binding.number;\n      groupedBindings[number] = groupedBindings[number] ? groupedBindings[number].concat(binding) : [binding];\n      return groupedBindings;\n    }, {}); // Sort the bindings by id (ascending), then, if there are multiple\n    // bindings for a single id, merge them together, aggregating movies as an\n    // array.\n\n    return Object.keys(bindingsById).map(number => parseInt(number, 10)) // convert ids from strings to numbers for sorting\n    .sort() // we do this sorting client-side because `Object.keys` ordering is not guaranteed\n    .map(number => {\n      // For each `id`, merge the bindings together as described above.\n      return bindingsById[number].reduce((bindingForTable, binding) => {\n        // Quick cleanup to remove IRI data that we don't want to display:\n        const bindingValues = Object.keys(binding).reduce((valueBinding, key) => {\n          const {\n            type,\n            value\n          } = binding[key];\n          valueBinding[key] = type !== \"uri\" ? value : value.slice(value.lastIndexOf(\"/\") + 1); // data cleanup\n\n          return valueBinding;\n        }, {}); // Aggregate movies on the `movies` property, deleting `movie`:\n\n        const movies = bindingValues.movie ? bindingForTable.movies.concat(bindingValues.movie) : bindingForTable.movies;\n        delete bindingValues.movie;\n        return { ...bindingForTable,\n          ...bindingValues,\n          movies\n        };\n      }, {\n        movies: []\n      });\n    });\n  }\n\n  render() {\n    const {\n      dataState,\n      data\n    } = this.state;\n    const isLoading = dataState === TableDataAvailabilityStatus.LOADING;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 157,\n        columnNumber: 5\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 158,\n        columnNumber: 5\n      }\n    }, /*#__PURE__*/React.createElement(\"input\", {\n      type: \"text\",\n      onChange: this.updateInput,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 159,\n        columnNumber: 5\n      }\n    }), /*#__PURE__*/React.createElement(\"input\", {\n      type: \"submit\",\n      onClick: this.handleSubmit,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 160,\n        columnNumber: 5\n      }\n    })), /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 162,\n        columnNumber: 5\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: \"App\",\n      style: styles.appInnerContainer,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 163,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(CssBaseline, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 164,\n        columnNumber: 9\n      }\n    }), /*#__PURE__*/React.createElement(Paper, {\n      style: styles.paper,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 165,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(Toolbar, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 166,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(Typography, {\n      variant: \"title\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 167,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"i\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 168,\n        columnNumber: 15\n      }\n    }, \"Bike Stations\"), \" with Stardog\")), isLoading ? /*#__PURE__*/React.createElement(CircularProgress, {\n      style: styles.spinner,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 171,\n        columnNumber: 24\n      }\n    }) : /*#__PURE__*/React.createElement(Table, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 172,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(TableHead, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 173,\n        columnNumber: 15\n      }\n    }, /*#__PURE__*/React.createElement(TableRow, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 174,\n        columnNumber: 17\n      }\n    }, columnHeaders)), /*#__PURE__*/React.createElement(TableBody, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 178,\n        columnNumber: 15\n      }\n    }, data.map((binding, index) => this.renderRowForBinding(binding, index))))))));\n  }\n\n}\n\nexport default SearchBike;","map":{"version":3,"sources":["/Users/chloebalcer/bikeStation/frontend/src/components/bikes/searchBike.js"],"names":["React","Component","CssBaseline","Paper","Table","TableBody","TableCell","TableHead","TableRow","Toolbar","Typography","CircularProgress","query","TableDataAvailabilityStatus","columnData","columnSelectors","conn","dbName","readQuery","SearchBike","constructor","props","state","dataState","NOT_REQUESTED","data","city","updateInput","bind","handleSubmit","event","setState","target","value","console","log","getBindingValueForSelector","selector","binding","bindingValue","Array","isArray","join","renderRowForBinding","index","number","map","componentDidMount","refreshData","LOADING","execute","then","res","ok","FAILED","bindings","body","results","bindingsForTable","getBindingsFormattedForTable","LOADED","bindingsById","reduce","groupedBindings","concat","Object","keys","parseInt","sort","bindingForTable","bindingValues","valueBinding","key","type","slice","lastIndexOf","movies","movie","render","isLoading","styles","appInnerContainer","paper","spinner","columnHeaders"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nimport Paper from \"@material-ui/core/Paper\";\nimport Table from \"@material-ui/core/Table\";\nimport TableBody from \"@material-ui/core/TableBody\";\nimport TableCell from \"@material-ui/core/TableCell\";\nimport TableHead from \"@material-ui/core/TableHead\";\nimport TableRow from \"@material-ui/core/TableRow\";\nimport Toolbar from \"@material-ui/core/Toolbar\";\nimport Typography from \"@material-ui/core/Typography\";\nimport CircularProgress from '@material-ui/core/CircularProgress';\nimport { query } from \"stardog\";\nimport {\n  TableDataAvailabilityStatus,\n  columnData,\n  columnSelectors,\n  conn,\n  dbName,\n} from \"../../helpers/constants\";\n\nconst readQuery = `select ?number ?address ?lat ?lng ?bikes ?stands ?commune\nwhere {\n    ?l <http://schema.org/number> ?number .\n    ?l <http://schema.org/address> ?address .\n    ?l <http://schema.org/available_bikes> ?bikes .\n    ?l <http://schema.org/available_bike_stands> ?stands .\n    ?l <http://schema.org/lat> ?lat .\n    ?l <http://schema.org/commune> {this.state.city} .\n    \n}\n`;\n\nclass SearchBike extends Component {\n\nconstructor(props){\nsuper(props);\n\nthis.state = {\n    dataState: TableDataAvailabilityStatus.NOT_REQUESTED,\n    data: [],\n    city : ''\n}\n\nthis.updateInput = this.updateInput.bind(this);\nthis.handleSubmit = this.handleSubmit.bind(this);\n}\n\n\nupdateInput(event){\nthis.setState({city : event.target.value})\n}\n\n\nhandleSubmit(){\nconsole.log('Your input value is: ' + this.state.city)\n//Send state to the server code\n}\n\ngetBindingValueForSelector(selector, binding) {\n    const bindingValue = binding[selector === \"movie\" ? \"movies\" : selector];\n    // NOTE: In a production app, we would probably want to do this formatting elsewhere.\n    return Array.isArray(bindingValue) ? bindingValue.join(\", \") : bindingValue;\n  }\n\n  renderRowForBinding(binding, index) {\n    return (\n      // Use every \"selector\" to extract table cell data from each binding.\n      <TableRow key={binding.number}>\n        {columnSelectors.map(selector => (\n          <TableCell key={selector}>\n            {this.getBindingValueForSelector(selector, binding)}\n          </TableCell>\n        ))}\n      </TableRow>\n    );\n  }\n  componentDidMount() {\n  this.refreshData();\n}\n\nrefreshData() {\n  this.setState({\n    dataState: TableDataAvailabilityStatus.LOADING\n  });\n  query.execute(conn, dbName, readQuery).then(res => {\n    if (!res.ok) {\n      this.setState({\n        dataState: TableDataAvailabilityStatus.FAILED\n      });\n      return;\n    }\n\n    const { bindings } = res.body.results;\n    const bindingsForTable = this.getBindingsFormattedForTable(bindings);\n\n    this.setState({\n      dataState: TableDataAvailabilityStatus.LOADED,\n      data: bindingsForTable\n    });\n  });\n}\n\n// Our SPARQL query returns a new \"row\" (i.e., variable binding) for each\n// character for each movie in which the character appears. We don't want to\n// _display_ multiple rows for the same character, though. Instead, we want\n// to show _one_ row for each character, and, if the character was in several\n// movies, we want to show them as a group within that character's single row. This\n// method goes through the bindings, groups them under each individual\n// character's id, then merges them together, aggregating the movies as an\n// array of strings. It also cleans up some of the data so that it's more\n// readable in the UI.\ngetBindingsFormattedForTable(bindings) {\n  // Group the bindings by each character id, in case multiple rows were\n  // returned for a single character.\n  const bindingsById = bindings.reduce((groupedBindings, binding) => {\n    const { value: number } = binding.number;\n    groupedBindings[number] = groupedBindings[number] ? groupedBindings[number].concat(binding) : [binding];\n    return groupedBindings;\n  }, {});\n\n  // Sort the bindings by id (ascending), then, if there are multiple\n  // bindings for a single id, merge them together, aggregating movies as an\n  // array.\n  return Object.keys(bindingsById)\n    .map(number => parseInt(number, 10)) // convert ids from strings to numbers for sorting\n    .sort() // we do this sorting client-side because `Object.keys` ordering is not guaranteed\n    .map(number => {\n      // For each `id`, merge the bindings together as described above.\n      return bindingsById[number].reduce(\n        (bindingForTable, binding) => {\n          // Quick cleanup to remove IRI data that we don't want to display:\n          const bindingValues = Object.keys(binding).reduce((valueBinding, key) => {\n            const { type, value } = binding[key];\n            valueBinding[key] = type !== \"uri\" ? value : value.slice(value.lastIndexOf(\"/\") + 1); // data cleanup\n            return valueBinding;\n          }, {});\n          // Aggregate movies on the `movies` property, deleting `movie`:\n          const movies = bindingValues.movie\n            ? bindingForTable.movies.concat(bindingValues.movie)\n            : bindingForTable.movies;\n          delete bindingValues.movie;\n          return {\n            ...bindingForTable,\n            ...bindingValues,\n            movies\n          };\n        },\n        { movies: [] }\n      );\n    });\n}\n\nrender(){\n    const { dataState, data } = this.state;\n    const isLoading = dataState === TableDataAvailabilityStatus.LOADING;\nreturn (\n    <div>\n    <div>\n    <input type=\"text\" onChange={this.updateInput}></input>\n    <input type=\"submit\" onClick={this.handleSubmit} ></input>\n    </div>\n    <div>\n      <div className=\"App\" style={styles.appInnerContainer}>\n        <CssBaseline />\n        <Paper style={styles.paper}>\n          <Toolbar>\n            <Typography variant=\"title\">\n              <i>Bike Stations</i> with Stardog\n            </Typography>\n          </Toolbar>\n          {isLoading ? <CircularProgress style={styles.spinner} /> : (\n            <Table>\n              <TableHead>\n                <TableRow>\n                  {columnHeaders}\n                </TableRow>\n              </TableHead>\n              <TableBody>\n                {data.map((binding, index) => this.renderRowForBinding(binding, index))}\n              </TableBody>\n            </Table>\n          )}\n        </Paper>\n      </div>\n      </div></div>\n  );\n}\n}\n\nexport default SearchBike;"]},"metadata":{},"sourceType":"module"}